<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Photo + GPS + Compass Logger</title>
  <style>
    :root { --bg:#0f172a; --fg:#e5e7eb; --muted:#9ca3af; --accent:#60a5fa; --card:#111827; }
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:var(--bg);color:var(--fg)}
    header{padding:12px 16px;border-bottom:1px solid #1f2937;display:flex;align-items:center;gap:12px}
    h1{font-size:18px;margin:0}
    main{display:grid;grid-template-columns:1fr 380px;gap:12px;height:calc(100% - 57px)}
    @media (max-width: 960px){ main{grid-template-columns:1fr; grid-auto-rows:min-content; height:auto} }
    .panel{background:var(--card);border:1px solid #1f2937;border-radius:12px;padding:12px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
    button,input[type="file"]{background:#1f2937;color:var(--fg);border:1px solid #374151;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
    button.primary{background:var(--accent);border-color:transparent;color:#0b1020}
    button:disabled{opacity:.5;cursor:not-allowed}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:8px}
    .thumb{border:1px solid #374151;border-radius:10px;overflow:hidden}
    .thumb img{display:block;width:100%;height:120px;object-fit:cover}
    .thumb .meta{padding:8px;font-size:12px;color:var(--muted);display:flex;flex-direction:column;gap:4px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    #map{height:60vh;border-radius:12px;border:1px solid #1f2937}
    .small{font-size:12px;color:var(--muted)}
    .pill{display:inline-flex;gap:6px;align-items:center;background:#0b1220;border:1px solid #263040;padding:6px 10px;border-radius:999px}
    details{margin-top:8px}
    summary{cursor:pointer;color:var(--muted)}
    #log{margin-top:8px;padding:8px;border:1px dashed #334155;border-radius:10px;font-size:12px;color:#eab308;background:#0b1220;max-height:140px;overflow:auto;white-space:pre-wrap}
  </style>
</head>
<body>
  <header>
    <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="5" width="18" height="14" rx="2" stroke="#60a5fa" stroke-width="2"/><circle cx="8.5" cy="12" r="3" fill="#60a5fa"/><path d="M12 12l1.8 1.8L17 10.5l4 4.5v2a2 2 0 0 1-2 2H5" stroke="#60a5fa" stroke-width="2"/></svg>
    <h1>Photo + GPS + Compass Logger</h1>
    <span class="pill" id="statusPill">Not tracking</span>
  </header>

  <main>
    <section class="panel">
      <div class="controls">
        <input id="fileInput" type="file" accept="image/*" capture="environment" />
        <button id="btnEnableCompass" title="Grant access to compass">Enable Compass</button>
        <button id="btnStartGPS" class="primary">Start GPS</button>
        <button id="btnStopGPS">Stop GPS</button>
        <button id="btnSavePoint" disabled>Save Point</button>
        <button id="btnShowMap">Show Map</button>
      </div>
      <div id="log" class="mono">Ready. If buttons do nothing, make sure you opened this from your GitHub Pages URL (https://yourname.github.io/...), not the repo viewer.</div>
      <div class="row small">
        <div>Lat/Lon: <span id="latlon" class="mono">–</span></div>
        <div>Accuracy: <span id="acc" class="mono">–</span> m</div>
        <div>Bearing: <span id="bearing" class="mono">–</span> °</div>
      </div>
      <details>
        <summary>What this does</summary>
        <ul class="small">
          <li>Use your camera to take a photo.</li>
          <li>Record your GPS position, accuracy and compass direction at the moment you save.</li>
          <li>Export as GeoJSON or a ready-made HTML map showing points, direction arrows and accuracy circles.</li>
        </ul>
      </details>

      <details>
        <summary>Diagnostics & tests</summary>
        <div class="controls"><button id="btnRunTests">Run self-tests</button></div>
        <p class="small">Runs a few sanity checks in the log and console.</p>
      </details>

      <h3>Captured points</h3>
      <div id="list" class="grid"></div>

      <div class="controls" style="margin-top:12px">
        <button id="btnExportGeoJSON">Export GeoJSON</button>
        <button id="btnExportHTML">Export HTML Map</button>
        <button id="btnClear">Clear</button>
      </div>
    </section>

    <aside class="panel">
      <h3 style="margin-top:0">Map</h3>
      <div id="map"></div>
      <p class="small">If the map is empty, add points then click Show Map. Accuracy is drawn as a circle; an arrow shows the bearing.</p>
    </aside>
  </main>

  <!-- Leaflet for in-app map preview -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>

  <script>
    // State
    const points = []; // {id, ts, lat, lon, acc, bearing, photoDataUrl}
    let watchId = null;
    let currentPosition = null; // {lat, lon, acc}
    let currentBearing = null;  // degrees
    let bearingSource = null;   // 'compass' | 'gps' | null
    let compassSupported = null; // true | false | null
    let compassActive = false;
    let warnedNoCompass = false;

    const els = {
      file: document.getElementById('fileInput'),
      btnEnableCompass: document.getElementById('btnEnableCompass'),
      btnStartGPS: document.getElementById('btnStartGPS'),
      btnStopGPS: document.getElementById('btnStopGPS'),
      btnSave: document.getElementById('btnSavePoint'),
      btnShowMap: document.getElementById('btnShowMap'),
      latlon: document.getElementById('latlon'),
      acc: document.getElementById('acc'),
      bearing: document.getElementById('bearing'),
      list: document.getElementById('list'),
      status: document.getElementById('statusPill'),
      btnExportGeoJSON: document.getElementById('btnExportGeoJSON'),
      btnExportHTML: document.getElementById('btnExportHTML'),
      btnClear: document.getElementById('btnClear'),
      log: document.getElementById('log'),
      btnRunTests: document.getElementById('btnRunTests')
    };

    function log(msg){ if(!els.log) return; els.log.textContent += '\n'+msg; els.log.scrollTop = els.log.scrollHeight; }

    // Prefer compass when available; fall back to GPS course.
    function chooseBearing(current, currentSource, gpsHeading){
      if (typeof gpsHeading === 'number' && !Number.isNaN(gpsHeading)){
        // Only use GPS if we don't already have compass
        if (currentSource !== 'compass'){
          const b = ((gpsHeading % 360) + 360) % 360;
          return { bearing: b, source: 'gps' };
        }
      }
      return { bearing: current, source: currentSource };
    }

    // Compass handling (iOS requires a tap + permission)
    function initCompass(){
      log('Compass init start');
      if (!isSecureContext){
        alert('This page must be served over HTTPS for compass. Use GitHub Pages, not the raw file viewer.');
        log('Not a secure context.');
        return;
      }
      function onOrientation(e){
        let b = null;
        if (typeof e.webkitCompassHeading === 'number') {
          b = e.webkitCompassHeading; // iOS
        } else if (typeof e.alpha === 'number') {
          b = 360 - e.alpha; // convert to compass-like bearing
        }
        if (b != null) {
          currentBearing = ((b % 360) + 360) % 360;
          bearingSource = 'compass';
          compassActive = true;
          compassSupported = true;
          els.bearing.textContent = currentBearing.toFixed(0);
          maybeEnableSave();
        } else {
          log('Orientation event had no heading yet. Move/rotate device.');
        }
      }

      try {
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
          DeviceOrientationEvent.requestPermission().then(state => {
            log('Compass permission: '+state);
            if (state === 'granted') { window.addEventListener('deviceorientation', onOrientation, true); compassSupported = true; }
            else { compassSupported = false; warnNoCompass(); }
          }).catch(err=> { compassSupported = false; warnNoCompass(); log(err.message||String(err)); });
        } else if (window.DeviceOrientationEvent){
          window.addEventListener('deviceorientation', onOrientation, true);
          compassSupported = true;
          log('Listening to deviceorientation');
        } else {
          compassSupported = false;
          warnNoCompass();
          log('DeviceOrientationEvent not available');
        }
      } catch(e){ log('Compass init error: '+ (e.message||e)); }
    }

    function warnNoCompass(){
      if (warnedNoCompass) return;
      warnedNoCompass = true;
      alert('No compass available or permission denied. Bearing will use GPS course while moving.');
      log('Warning: compass unavailable; using GPS heading when moving.');
    }

    els.btnEnableCompass.addEventListener('click', initCompass);

    // GPS handling
    function startGPS(){
      log('Starting GPS');
      if (!('geolocation' in navigator)){
        alert('Geolocation not supported.');
        log('navigator.geolocation missing');
        return;
      }
      // If user never tapped Enable Compass, we can still warn once when tracking starts
      if (compassSupported === false) warnNoCompass();
      // Try to preflight permission where supported
      try{ navigator.permissions && navigator.permissions.query({name:'geolocation'}).then(p=>log('Geo permission: '+p.state)); }catch{}
      els.status.textContent = 'Tracking…';
      els.status.style.borderColor = '#60a5fa';
      els.status.style.color = '#60a5fa';
      watchId = navigator.geolocation.watchPosition(pos => {
        const { latitude:lat, longitude:lon, accuracy:acc, heading } = pos.coords;
        currentPosition = { lat, lon, acc };
        els.latlon.textContent = lat.toFixed(6)+', '+lon.toFixed(6);
        els.acc.textContent = acc.toFixed(1);
        // Prefer existing compass; otherwise adopt GPS heading when provided
        const chosen = chooseBearing(currentBearing, bearingSource, heading);
        if (chosen.source === 'gps' && bearingSource !== 'compass'){
          currentBearing = chosen.bearing;
          bearingSource = 'gps';
          els.bearing.textContent = currentBearing.toFixed(0);
          log('Using GPS heading: '+currentBearing.toFixed(0)+'°');
        }
        maybeEnableSave();
      }, err => {
        alert('GPS error: '+ err.message);
        log('GPS error: '+err.message+' (code '+err.code+')');
      }, {
        enableHighAccuracy: true, timeout: 15000, maximumAge: 0
      });
    }

    function stopGPS(){
      if (watchId != null){ navigator.geolocation.clearWatch(watchId); watchId = null; }
      els.status.textContent = 'Not tracking';
      els.status.style.borderColor = '#263040';
      els.status.style.color = '#9ca3af';
    }

    els.btnStartGPS.addEventListener('click', startGPS);
    els.btnStopGPS.addEventListener('click', stopGPS);

    // Handle photo input
    let lastPhotoDataUrl = null;
    els.file.addEventListener('change', async (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const dataUrl = await fileToDataURL(f);
      lastPhotoDataUrl = dataUrl;
      maybeEnableSave();
    });

    function maybeEnableSave(){
      els.btnSave.disabled = !(lastPhotoDataUrl && currentPosition);
    }

    // Save point
    els.btnSave.addEventListener('click', ()=>{
      if (!currentPosition || !lastPhotoDataUrl){
        alert('Need a photo and a GPS fix first.');
        return;
      }
      const p = {
        id: self.crypto && crypto.randomUUID ? crypto.randomUUID() : String(Date.now())+Math.random().toString(16).slice(2),
        ts: new Date().toISOString(),
        lat: currentPosition.lat,
        lon: currentPosition.lon,
        acc: currentPosition.acc,
        bearing: typeof currentBearing === 'number' ? currentBearing : null,
        photoDataUrl: lastPhotoDataUrl
      };
      points.push(p);
      renderList();
      refreshMap();
      // reset photo
      els.file.value = '';
      lastPhotoDataUrl = null;
      els.btnSave.disabled = true;
    });

    // Render list
    function renderList(){
      els.list.innerHTML = '';
      for (const p of points){
        const div = document.createElement('div');
        div.className = 'thumb';
        const img = document.createElement('img');
        img.src = p.photoDataUrl;
        img.alt = 'photo';
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.innerHTML = `
          <div class="mono">${p.lat.toFixed(6)}, ${p.lon.toFixed(6)}</div>
          <div>± ${p.acc.toFixed(1)} m • ${p.bearing!=null?('↗ '+p.bearing.toFixed(0)+'°'):'no bearing'}</div>
          <div class="small">${new Date(p.ts).toLocaleString()}</div>
          <div class="row">
            <button data-id="${p.id}" class="del">Delete</button>
            <button data-id="${p.id}" class="dl">Download photo</button>
          </div>`;
        div.appendChild(img);
        div.appendChild(meta);
        els.list.appendChild(div);
      }
      // wire buttons
      els.list.querySelectorAll('button.del').forEach(b=>b.onclick = () => {
        const id = b.getAttribute('data-id');
        const idx = points.findIndex(x=>x.id===id);
        if (idx>=0){ points.splice(idx,1); renderList(); refreshMap(); }
      });
      els.list.querySelectorAll('button.dl').forEach(b=>b.onclick = () => {
        const id = b.getAttribute('data-id');
        const p = points.find(x=>x.id===id);
        if (p) downloadBlob(dataURLToBlob(p.photoDataUrl), `photo_${p.id}.jpg`);
      });
    }

    // Simple in-app map preview using Leaflet
    let map, layerGroup;
    function ensureMap(){
      if (!map){
        map = L.map('map');
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap' }).addTo(map);
        layerGroup = L.layerGroup().addTo(map);
      }
    }

    function refreshMap(){
      ensureMap();
      layerGroup.clearLayers();
      if (points.length === 0){ return; }
      const ll = [];
      for (const p of points){
        const latlng = [p.lat, p.lon];
        ll.push(latlng);
        const popupHtml = `<div style="min-width:180px">
          <div><strong>${new Date(p.ts).toLocaleString()}</strong></div>
          <div class="mono">${p.lat.toFixed(6)}, ${p.lon.toFixed(6)}</div>
          <div>± ${p.acc.toFixed(1)} m ${p.bearing!=null?('• '+p.bearing.toFixed(0)+'°'):''}</div>
          <img src="${p.photoDataUrl}" style="width:100%;margin-top:6px;border-radius:8px"/>
        </div>`;
        L.marker(latlng).addTo(layerGroup).bindPopup(popupHtml);
        // accuracy circle
        L.circle(latlng, { radius: p.acc, color:'#60a5fa', weight:1, fillOpacity:0.08 }).addTo(layerGroup);
        // direction arrow: a short 20 m line
        if (typeof p.bearing === 'number'){
          const dest = destinationPoint(p.lat, p.lon, p.bearing, 20);
          L.polyline([latlng, [dest.lat, dest.lon]], { weight:3 }).addTo(layerGroup);
        }
      }
      const b = L.latLngBounds(ll);
      map.fitBounds(b.pad(0.2));
    }

    document.getElementById('btnShowMap').addEventListener('click', refreshMap);

    // Export GeoJSON
    els.btnExportGeoJSON.addEventListener('click', ()=>{
      const fc = {
        type: 'FeatureCollection',
        features: points.map(p=>({
          type:'Feature',
          geometry:{ type:'Point', coordinates:[p.lon, p.lat] },
          properties:{ id:p.id, timestamp:p.ts, accuracy:p.acc, bearing:p.bearing, photo:p.photoDataUrl }
        }))
      };
      downloadBlob(new Blob([JSON.stringify(fc,null,2)], {type:'application/geo+json'}), 'photo_points.geojson');
    });

    // Export standalone HTML map (references Leaflet CDN)
    els.btnExportHTML.addEventListener('click', ()=>{
      const data = points.map(p=>({ lat:p.lat, lon:p.lon, acc:p.acc, bearing:p.bearing, ts:p.ts, photo:p.photoDataUrl }));
      const html = buildMapHTML(data);
      downloadBlob(new Blob([html], {type:'text/html'}), 'map.html');
    });

    // Clear
    els.btnClear.addEventListener('click', ()=>{
      if (confirm('Delete all captured points?')){ points.splice(0, points.length); renderList(); refreshMap(); }
    });

    // Utils
    function fileToDataURL(file){
      return new Promise((res, rej)=>{ const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsDataURL(file); });
    }
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      setTimeout(()=> URL.revokeObjectURL(url), 1000);
    }
    function dataURLToBlob(dataUrl){
      const [h,b64] = dataUrl.split(',');
      const mimeMatch = /data:(.*?);base64/.exec(h);
      const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
      const bin = atob(b64); const len = bin.length; const u8 = new Uint8Array(len);
      for (let i=0;i<len;i++) u8[i] = bin.charCodeAt(i);
      return new Blob([u8], {type:mime});
    }
    // Destination point given start lat/lon, bearing (deg), distance meters
    function destinationPoint(lat, lon, bearingDeg, distM){
      const R = 6371000; // m
      const brng = bearingDeg * Math.PI/180;
      const phi1 = lat * Math.PI/180; const lam1 = lon * Math.PI/180;
      const d = distM / R;
      const phi2 = Math.asin(Math.sin(phi1)*Math.cos(d) + Math.cos(phi1)*Math.sin(d)*Math.cos(brng));
      const lam2 = lam1 + Math.atan2(Math.sin(brng)*Math.sin(d)*Math.cos(phi1), Math.cos(d)-Math.sin(phi1)*Math.sin(phi2));
      return { lat: phi2*180/Math.PI, lon: ((lam2*180/Math.PI + 540)%360)-180 };
    }

    function buildMapHTML(data){
      // Escape </script> to avoid breaking the outer script
      const leafletCss = '<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous">';
      const leafletJs = '<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"><' + '/script>';
      const inlineScript = `<script>const data=${JSON.stringify(data)};const map=L.map('map');L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20,attribution:'&copy; OpenStreetMap'}).addTo(map);const g=L.layerGroup().addTo(map);const ll=[];function dest(lat,lon,brg,dist){const R=6371000,br=brg*Math.PI/180,phi1=lat*Math.PI/180,lam1=lon*Math.PI/180,del=dist/R;const phi2=Math.asin(Math.sin(phi1)*Math.cos(del)+Math.cos(phi1)*Math.sin(del)*Math.cos(br));const lam2=lam1+Math.atan2(Math.sin(br)*Math.sin(del)*Math.cos(phi1),Math.cos(del)-Math.sin(phi1)*Math.sin(phi2));return{lat:phi2*180/Math.PI,lon:(lam2*180/Math.PI+540)%360-180}};data.forEach(p=>{const latlng=[p.lat,p.lon];ll.push(latlng);const html=\`<div class=pop><b>\${new Date(p.ts).toLocaleString()}</b><br><span>\${p.lat.toFixed(6)}, \${p.lon.toFixed(6)}</span><br><span>&plusmn; \${p.acc.toFixed(1)} m \${p.bearing!=null?'• '+p.bearing.toFixed(0)+'°':''}</span><br><img src=\\\"\${p.photo}\\\"></div>\`;L.marker(latlng).addTo(g).bindPopup(html);L.circle(latlng,{radius:p.acc,color:'#3b82f6',weight:1,fillOpacity:.08}).addTo(g);if(typeof p.bearing==='number'){const d=dest(p.lat,p.lon,p.bearing,20);L.polyline([latlng,[d.lat,d.lon]],{weight:3}).addTo(g)}});if(ll.length){map.fitBounds(L.latLngBounds(ll).pad(.2))}<' + '/script>`;
      const htmlDoc = `<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Map Export</title>
      ${leafletCss}
      <style>html,body,#map{height:100%;margin:0} .pop img{max-width:240px;border-radius:8px}</style></head>
      <body><div id="map"></div>
      ${leafletJs}
      ${inlineScript}
      </body></html>`;
      return htmlDoc;
    }

    // ---------- Simple self-tests ----------
    function runTests(){
      const results = [];
      function assert(name, cond){ results.push({name, pass: !!cond}); if(!cond) console.error('Test failed:', name); }

      // destinationPoint: forward then back ~ same lon/lat
      const start = {lat:51.5, lon:-0.1};
      const d1 = destinationPoint(start.lat, start.lon, 0, 1000); // 1km north
      const d2 = destinationPoint(d1.lat, d1.lon, 180, 1000); // back south
      const distBack = Math.hypot((d2.lat-start.lat)*111320, (d2.lon-start.lon)*40075000/360*Math.cos(start.lat*Math.PI/180));
      assert('destinationPoint round-trip ~1m', distBack < 2);

      // GeoJSON export shape
      const tmpPoints = [{id:'a', ts:'2020-01-01', lat:0, lon:0, acc:5, bearing:90, photoDataUrl:'data:image/png;base64,'}];
      const fc = { type:'FeatureCollection', features: tmpPoints.map(p=>({ type:'Feature', geometry:{ type:'Point', coordinates:[p.lon,p.lat]}, properties:{id:p.id,timestamp:p.ts,accuracy:p.acc,bearing:p.bearing,photo:p.photoDataUrl} })) };
      assert('GeoJSON has one feature', Array.isArray(fc.features) && fc.features.length===1 && fc.features[0].geometry.type==='Point');

      // dataURLToBlob tiny data
      const tiny = 'data:text/plain;base64,YQ=='; // 'a'
      const blob = dataURLToBlob(tiny);
      assert('dataURLToBlob returns Blob', blob instanceof Blob && blob.size===1);

      // HTML export should escape </script>
      const html = buildMapHTML([{lat:0,lon:0,acc:1,bearing:null,ts:'x',photo:''}]);
      assert('buildMapHTML escapes </script>', html.includes('<\\/script>') || html.includes('<' + '/script>'));

      // HTML export should be properly closed
      assert('exported HTML ends with </html>', /<\/html>\s*$/.test(html));
      assert('exported HTML contains </body>', /<\/body>/.test(html));

      // refreshMap safe with no points
      try { refreshMap(); assert('refreshMap with 0 points does not throw', true); } catch(e){ assert('refreshMap with 0 points does not throw', false); }

      // chooseBearing logic: prefer compass over gps
      const res1 = chooseBearing(123, 'compass', 250);
      assert('chooseBearing keeps compass when available', res1.bearing === 123 && res1.source === 'compass');
      const res2 = chooseBearing(null, null, 250);
      assert('chooseBearing adopts gps when no compass', res2.source === 'gps' && Math.abs(res2.bearing-250) < 0.001);

      // Additional: buildMapHTML contains one map div
      assert('exported HTML contains #map div', /<div id=\"map\"><\/div>/.test(html));

      // Log summary
      const passed = results.filter(r=>r.pass).length;
      log(`Tests: ${passed}/${results.length} passed`);
      results.forEach(r=> log(`${r.pass?'✅':'❌'} ${r.name}`));
    }
    if (els.btnRunTests) els.btnRunTests.addEventListener('click', runTests);

  </script>
</body>
</html>
<!-- build: r1 -->
